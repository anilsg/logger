#!/usr/bin/env python
# Python 3.6.3
# logger_httpd.py

"""
logger_httpd.py:
The remote logging server receives POST messages and drops them as individual files into the cache.
Also responds to GET requests to retrieve logs and potentially other REST requests.
This process runs separately in addition to logger_collector.py.

TODO: Convert text/plain responses to JSON.
TODO: Basic auth over SSL. Could use an HMAC of visible parameters and a secret but SSL basic auth sufficient.
TODO: Forking to handle more requests (if required).
TODO: Matching name/value pairs in GET requests e.g. userid=xyz.
"""

import os
import datetime
from http.server import BaseHTTPRequestHandler, HTTPServer
from urllib.parse import parse_qs

from logger_resource import GetFilter


class restHandler(BaseHTTPRequestHandler):
    """
    Handle POST and GET requests to REST API to log and retrieve messages.
    """

    cache_path = '/srv/logger/cache' # This is the cache destination for all messages received.

    def do_POST(self):
        """
        Accept and store individual POSTed messages in url-encoded format, as sent by logging.handlers.HTTPHandler from logger_remote.py.
        Messages are dropped in individual files in the primary cache directory.
        Messages must POST to /api/v1/messages with these parameters.
        Parameters align to those generated and used by standard library logging module.

        created:    Is a datetime timestamp generated by the logger like this: 1512386686.0873692.
        name:       Is the facility name given to logger on creation, using usual identifier syntax: alphanumeric, underscore, no spaces.
        levelno:    The usual logging level numeric equivalent: emerg=70 alert=60 crit=50 error=40 warn=30 notice=25 info=20 debug=10.
        msg:        Static string description of error, without embedded formatting or variables, to support counting identical errors.
        name/value: Additional arbitrary name/values allowed and will be logged (clients may co-ordinate same names for analysis).
        token:      Authentication token not supported.
        hmac:       HMAC signature not supported.

        POST equivalent:
        curl -i -d 'name=facility_name' -d 'levelno=40' -d 'msg=error message' -d 'created=1512386686.123456' -d 'additional_key=additional_value' http://localhost:8080/api/v1/messages
        """
        if str(self.path) != '/api/v1/messages': # Only accept POST requests to this single API.
            return self.send_error(404, 'URI Not Allowed (Use /api/v1/messages)') # Descriptive error response.
        if self.headers['content-type'] != 'application/x-www-form-urlencoded': # Only accept url-encoded requests.
            return self.send_error(400, 'Bad Request (Requires application/x-www-form-urlencoded)') # Descriptive response.
        try:
            content = self.rfile.read(int(self.headers['content-length'])) # Content arrives in unencoded bytes.
            content = content.decode() # Decode to utf-8 string, and should contain url-encoded parameters.
            self.log(content) # Write the message as an individual file in the primary cache.
            self.send_response(201) # Respond OK straight away.
            self.send_header('Content-type', 'text/plain')
            ## self.send_header('Content-length', str(len(content))) # No need to reflect submitted content back.
            self.end_headers()
            ## self.wfile.write(bytes(content, "utf-8"))
        except Exception as e: # Something went wrong, send description back.
            self.send_error(500, 'Server error: ' + repr(e))
        return

    def do_GET(self):
        """
        Respond to GET requests to return messages, counts and ranges of values available.
        Only counts implemented so far.
        Filter parameters are supplied in the resource path. URL parameters are not used.
        URLs are of the form /api/v1/<resource>/<since>/<until>/<levels>/<facility_name>/<facility_name>/...
        Where <since> and <until> are date/times of the form "YYYYMMDD-HHMMSS". Microsecond resolution is not supported.
        Where <levels> are expressed as double digit numbers either an individual level "LL" or a range "LL-MM".
        Values omitted are taken to mean "including all".
        Refer to logger_resource.py.
        """
        try:
            filtered = GetFilter(self.path) # Initialises filter, parsing GET request, in logger_resource.py.
            if filtered.resource == 'messages': # Return a number of actual messages as stored.
                return self.send_error(501, 'Response for messages resource not yet implemented')
            if filtered.resource == 'ranges': # Return a list of potential values for particular parameters.
                return self.send_error(501, 'Response for ranges resource not yet implemented')
            if filtered.resource == 'counts': # Count the number of messages in the provided range.
                filtered.get_counts() # Count all log lines specified in filter.
                content = 'message_count=' + str(filtered.message_count) # TODO: Convert to JSON.
                self.send_response(200)
                self.send_header('Content-type', 'text/plain')
                self.send_header('Content-length', str(len(content)))
                self.end_headers()
                self.wfile.write(bytes(content, "utf-8"))
                return
            return self.send_error(501, 'Unknown resource type')
        except:
            self.send_error(500)
        return

    def do_DELETE(self):
        """
        REST DELETE could be used to flush messages, in addition to the automated expiry.
        Could also move archived records off-line for potential restore, space allowing.
        """
        self.send_error(501) # Not yet implemented.

    def log(self, content):
        """
        Log single message as a single file to the primary cache directory and return to complete log request quickly.
        content contains the url-encoded utf-8 string defining all content for the message.
        Messages are logged as individual files named YYYYMMDD-HHMMSS.uuuuuu-level-facility to the cache directory in self.cache_path.
        Separately managed logger_collector.py process then appends the individual messages onto log files organised for easy retrieval.
        (This avoids managing sub-processes in this server and provides reliable logging even when processes get killed.
        Queues deliver messages out of order, and can become corrupted if processes fail while using the queue.)
        TODO: Replace newlines with spaces in content string. Newlines will be damaging if included, just disallow by converting to spaces.
        TODO: Default to UTC now() if created timestamp is missing.
        TODO: Catch exceptions and report sensibly.
        """
        # Decode url-encoded pairs.
        pairs = parse_qs(content, keep_blank_values=True) # Extract from url-encoded string into lists of values.
        (created, levelno, facility, message) = [pairs.get(key, '') for key in ('created', 'levelno', 'name', 'msg')] # Extracts as lists.
        
        # Check and process supplied parameters.
        created = created and float(created[0]) or 0.0 # Take first list element and convert to float timestamp.
        created = datetime.datetime.fromtimestamp(created, tz=datetime.timezone.utc) # Convert epoch stamp to UTC datetime.
        created = '{0:%Y%m%d-%H%M%S}.{1:0<6d}'.format(created, created.microsecond) # And convert to string format required for storing.
        if len(created) != 22: # Expecting YYYYMMDD-HHMMSS.uuuuuu.
            return self.send_error(400, 'Bad Request (created must be timestamp ssssssssss.uuuuuu)')

        levelno = levelno and levelno[0] or '00' # Take first item in list or generate default: 00=LOG_UNSPECIFIED. Retain as string.
        if len(levelno) != 2 or not levelno.isdigit(): # 70=LOG_EMERG, 60=LOG_ALERT, 50=LOG_CRIT, 40=LOG_ERR, 30=LOG_WARNING 25=LOG_NOTICE, 20=LOG_INFO, 10=LOG_DEBUG.
            return self.send_error(400, 'Bad Request (levelno must be double digit numeric)')

        facility = facility and facility[0] or 'no_facility' # Convert from a list of values, possibly undefined, to a reliable scalar.
        message = message and message[0] or 'no_message' # Choosing not to complain if really useful parameters are not supplied.

        # Construct cached message name and internal information.
        filename ='{created}-{levelno}-{facility}'.format(created=created, levelno=levelno, facility=facility)
        logline ='{filename}:{message}:{content}\n'.format(filename=filename, message=message, content=content)

        # Write the message to the temporary cache.
        with open(os.path.join(self.cache_path, filename), mode='a', encoding='utf-8') as outfile:
            outfile.write(logline) # Append rather than write protects against rare collisions and should work, retaining both messages.


if __name__ == '__main__': # Run python logger_httpd.py in addition to python logger_collector.py.
    httpd = HTTPServer(('', 8080), restHandler) # httpd.timeout = 10 # Simple attempt to force timeout fails.
    print(str(httpd))
    try: httpd.serve_forever()
    except KeyboardInterrupt: pass
    httpd.server_close()

    ## HTTPS recipe:
    ## Using HTTP for now, implementing HTTPS is a simple improvement.
    ## from http.server import HTTPServer, BaseHTTPRequestHandler
    ## import ssl
    ## httpd = HTTPServer(('localhost', 4443), SimpleHTTPRequestHandler)
    ## httpd.socket = ssl.wrap_socket (httpd.socket, keyfile="path/to/key.pem", certfile='path/to/cert.pem', server_side=True)
    ## httpd.serve_forever()

    ## Forking recipe:
    ## class ForkingHTTPServer(socketserver.ForkingMixIn, HTTPServer):
    ##     def finish_request(self, request, client_address):
    ##         request.settimeout(30)
    ##         HTTPServer.finish_request(self, request, client_address)
    ## 
    ## if __name__ == '__main__':
    ##     httpd = ForkingHTTPServer(('', 8080), restHandler)
    ##     print(str(httpd))
    ##     try: httpd.serve_forever()
    ##     except KeyboardInterrupt: pass
    ##     httpd.socket.close()

